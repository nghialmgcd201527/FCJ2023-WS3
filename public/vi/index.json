[
{
	"uri": "/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Trước khi đi vào những bài labs, đây là phần sẽ giới thiệu những kiến thức cơ bản cần học và hiểu được trong bài workshop này.\n"
},
{
	"uri": "/vi/3-cache/3.1-urired/",
	"title": "URI based Redirects",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ bắt đầu với một trường hợp đơn giản có thể dễ dàng hiểu được bằng cách sử dụng Lambda@Edge vì trường hợp này có thể được cached, do đó sẽ tốt nhất khi xử lí bằng các Lambda@Edge.\nTrường hợp này thường được sử dụng để redirect users vì một lí do nào đó khi request URI mà admin không muốn users đó xem hoặc URI có thể không khả dụng nữa. Ví dụ, user có thể gửi request đến /uri-main.html, tuy nhiên, admin muốn tất cả request đó được thực hiện bởi /uri-redirect.html\nStep 1: Tạo ra Cache Behavior cho trường hợp này Để thực hiện được trường hợp này, đầu tiên bạn sẽ tạo ra một cache behavior cụ thể. Các bước sau dây sẽ hướng dẫn để làm trường hợp này.\nĐi đến CloudFront console. Các bạn sẽ thấy Distribution được tạo ra bởi CloudFormation template, nó sẽ được xác định bởi Edge Redirect Workshop Distribution như ở mục Description. Chọn Distribution đó sau đó chọn vào mục Behaviors. Click vào nút Create Behavior. Ở mục Path pattern, chúng ta nhập /uri-main.html, ở dưới là phần Origin and origin groups, chúng ta chọn myS3Origin. Ở phần Viewer protocol policy, chúng ta chọn Redirect HTTP to HTTPS. Những mục còn lại chúng ta sẽ để mặc định và click vào nút Create behavior ở cuối trang. Step 2: Tạo Lambda@Edge function và publish new version Bước này sẽ là quá trình tạo ra function của chúng ta cùng với version của nó. Các Lambda@Edge functions cần được CloudFront Distribution refer dựa vào version ARN của chúng chứ không phải main function ARN của chúng.\nĐi vào Lambda Console ỏ AWS Region us-east-1, click vào nút Create function. Ở trang Create function, đặt tên cho function của chúng ta là edge-uri-redirect, chọn Python 3.9 cho phần Runtime. Ở phía dưới, chúng ta mở mục Change default execution role rồi chọn Use an existing role, chúng ta chọn edge-redirect-lambda-role (đây là role được tạo từ CloudFormation template). Cuối cùng là click vào nút Create function. Khi function được tạo xong, chúng ta ở trang chính của function đó. Ở phần Code ở dưới, chúng ta copy đoạn code dưới đây và paste vào phần Code source. import json\rdef lambda_handler(event, context):\rget_uri = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;uri\u0026#39;]\rprint(get_uri)\rif (get_uri == \u0026#39;/uri-main.html\u0026#39;):\rresponse = {\r\u0026#39;status\u0026#39;: \u0026#39;301\u0026#39;,\r\u0026#39;statusDescription\u0026#39;: \u0026#39;Permanent Redirect\u0026#39;,\r\u0026#39;headers\u0026#39;: {\r\u0026#39;location\u0026#39;: [{\r\u0026#39;key\u0026#39;: \u0026#39;Location\u0026#39;,\r\u0026#39;value\u0026#39;: \u0026#39;/uri-redirect.html\u0026#39;\r}]\r}\r}\rreturn response\relse:\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request Ở đoạn code này được dùng như một AWS CloudFront function. Nó phục vụ cho CloudFront event handler và implement logic cho URL redirection dựa vào URI được request. Function lambda_handler là entry point của Lambda function, nó gồm 2 parameters là event và context. Function này extract URI được request từ CloudFront event. Nếu request URI là /uri-main.html, code sẽ trả về một response với status code 301 và location header được set là /uri-redirect.html. Nếu URI không phải là /uri-main.html, code sẽ trả về request object.\nTiếp theo, click vào nút Deploy để code của lambda function của chúng ta được commit. Khi code của chúng ta được deploy thành công, chúng ta sẽ publish version mới cho lambda này. Click vào nút Actions ở góc bên phải, chúng ta chọn Publish new version. Chúng ta nhập edge-uri-redirect-v1 cho phần Version description và click vào nút Publish.\nStep 3: Kết hợp Lambda Function với CloudFront Behavior Quay trở lại lambda function console và mở function edge-uri-redirect.\nClick vào + Add trigger\nỞ trang Trigger configuration, chúng ta chọn CloudFront cho phần source. Sau đó click vào Deploy on Lambda@Edge. Có một cửa số mới mở ra, ở phần Distribution, chúng ta chọn distribution được tạo từ CloudFormation template. Phần Cache behavior, chúng ta chọn /uri-main.html. Ở phần CloudFront event, chọn Origin request. Đánh dấu vào ô Confirm deploy to Lambda@Edge và click vào nút Deploy. Step 4: Set up client cho testing Để test redirect cụ thể, chúng ta sẽ cần một client để chạy curl commands. Cách dễ dàng đó là tạo CloudShell Environments. CloudShell là một shell có sẵn trong AWS console và chúng ta có thể chạy những Linux command từ nó. Đi đến CloudShell Console và chờ đến khi terminal sẵn sàng để dùng.\nNếu CloudShell không hoạt động thì nếu bạn đang thực hành bài workshop này ở Linux/MacOS client thì hai hệ điều hành này đã có sẵn curl và bạn chỉ cần chạy command ở client đó. Nếu bạn đang thực hành trên Windows thì hãy tận dùng online curl tools như cái này. Có thể chạy EC2 instance hoặc Cloud9 IDE từ AWS COnsole để chạy commands.\nStep 5: Test redirect configuration Đi đến CloudShell Console.\nTrong phần test, chúng ta sẽ chạy câu lệnh curl để gửi http request đối với distrubtion của chúng ta, để làm như vậy, chúng ta cần copy Distribution domain name từ CloudFront console nơi chúng ta có thể tìm thấy.\nKhi đã tìm thấy distribution domain name, copy câu lệnh sau và thay thế domain name của chúng ta vào.\ncurl -v -o /dev/null https://\u0026lt;YOUR-DISTRIBUTION-DOMAIN-NAME\u0026gt;/uri-main.html Sau khi build câu lệnh trên từ cloudshell, chúng ta sẽ thấy kết quả như dưới đây. Chúng ta có thể thấy ở kết quả trên, request này nhận response HTTP 301, biểu thị redirect và Location header là URI nơi mà client được redirect đến.\nBây giờ, chúng ta chạy lại cùng câu lệnh trên. Và xem sự khác biệt. Sự khác biệt ở lần chạy câu lệnh này lại là giá trị của X-Cache header. Request bây giờ nhận response được redirect và đã được cache từ lần chạy câu lệnh trước đó. Có nghĩa là Lambda@edge của chúng ta không cần trigger lại, tiết kiệm thời gian và chi phí.\nChúng ta đã deploy thành công redirect đầu tiên bằng Lambda@Edge và đã test xong. Bây giờ chúng ta di chuyển sang trường hợp tiếp theo.\n"
},
{
	"uri": "/vi/1-introduce/1.1-usecase/",
	"title": "Use Cases",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ tìm hiểu thông tin cơ bản về các tính năng của Edge Compute mà chúng ta sẽ khám phá trong bài workshop này. Nó sẽ cung cấp cho chúng ta kiến thức nền tảng và nội dung liên quan đến các bài labs.\nTrước khi giới thiệu về AWS Edge computes, chúng ta cần có những kiến thức về các techniques khác nhau được sử dụng trong bài workshop này để chuyển hướng các trang từ trang khác từ yêu cầu của người dùng. Nó được gọi là Redirects và Rewrites.\nRedirects: URL redirections đưa trình duyệt đến một resource mới hoặc một trang web khác. Các HTTP response codes phổ biến là HTTP 301, HTTP 302 và HTTP 308. Sau khi trình duyệt nhận được response từ server, nó sẽ fetch content từ URL mà server trả về. Để biết thêm thông tin, hãy xem ở đây. Có một số trường hợp cần sử dụng đó là khách hàng muốn Redirects bao gồm các tình huống cần routing users đến domain mới hoặc ngay cả khi redirect users đến website chính, redirect để đưa user đến trang dựa vào thiết bị hoặc vị trí địa lí của họ và những trường hợp khác mà chúng ta sẽ tìm hiểu trong bài workshop này.\nRewrites: URL rewrites cũng là một technique được sử dụng để lưu trữ một nội dung khác với nội dung users yêu cầu, tuy nhiên nó sẽ không xử lí một redirect đầy đủ. Thay vào đó, nó sẽ chỉ phục vụ một nội dung khác từ phía backend của website hoặc ứng dụng mà user không hề biết hoạt gì đang diễn ra. Ví dụ, chúng ta có thể nghĩ về việc trình duyệt gửi GET request để fetch nội dung cho \u0026ldquo;/index.html\u0026rdquo;, tuy nhiên có thể sửa đổi URL theo yêu cầu này và làm cho phía backend trả về nội dung từ \u0026ldquo;/index_rewrite.html\u0026rdquo;. Việc này về cơ bản sẽ cung cấp nội dung khác với yêu cầu ban đầu mà không cần server đưa user đến với URL/page hoàn toàn khác. Một số trường hợp sử dụng rewrite URL là các trường hợp cần phải sắp xếp lại các kí tự từ URL, trong trường hợp này, nó sẽ lấy content về và không thay đổi URL là rất quan trọng để trải nghiệm của user có thể đơn giản hơn và những trường hợp khác mà chúng ta sẽ tìm hiểu trong bài workshop này.\n"
},
{
	"uri": "/vi/",
	"title": "Using Edge Functions to handle Rewrites and Redirects",
	"tags": [],
	"description": "",
	"content": "Sử dụng Edge Functions để xử lí Rewrites và Redirects Tổng quan Trong bài workshop này, chúng ta sẽ tìm hiểu cách xử lí các trường hợp redirect và rewrite phổ biến bằng cách sử dụng các tính năng của Edge Compute được cung cấp bởi AWS.\nMục tiêu chính của việc này là cung cấp cho người xem kiến thức về cách sử dụng các tính năng của Edge Compute để áp dụng được redirects cho ứng dụng của họ và hiểu cách sử dụng các tính năng đó hiệu quả nhất.\nBài workshop này là nơi bạn sẽ thực hiện các bài labs sử dụng Compute platforms có sẵn trong CloudFront để tiếp cận được những trường hợp redirects và rewrites khác nhau. Ở đây chúng ta sẽ sử dụng Lambda@Edge vì những responses từ các trường hợp này là cacheable responses.\nPrerequisites Để hoàn thành bài workshop này, chúng ta cần có kiến thức về CDNs và kiến thức lập trình cơ bản JavaScript/Python để hiểu các đoạn code và những kiến thức xuyên suốt bài workshop.\nNội dung Giới thiệu Solution Deployment Trường hợp cho Cacheable Dọn dẹp tài nguyên "
},
{
	"uri": "/vi/1-introduce/1.2-edge/",
	"title": "Edge Compute",
	"tags": [],
	"description": "",
	"content": "Trước khi bắt tay vào thực hành bài lab, chúng ta nên hiểu cơ bản về loại edge compute capabilities mà chúng ta sẽ sử dụng trong bài lab này, hiện nay đang có sẵn trong CloudFront.\nCloudFront Edge Compute Features Lambda@Edge: Đây là một tính năng của Amazon CloudFront cho phép bạn chạy code gần hơn với users ứng dụng của chúng ta, giúp cải thiện hiệu suất và giảm độ trễ. Với Lambda@Edge, chúng ta không phải cung cấp hoặc quản lí cơ sở hạ tầng ở nhiều locations trên khắp thế giới. chúng ta chỉ trả phí cho thời gian compute mà chúng ta sử dụng và không tính phí khi code của chúng ta đang không sử dụng. Với Lambda@Edge, chúng ta có thể làm phong phú hơn các ứng dụng web của chúng ta bằng cách phân phối chúng trên toàn cầu và cải thiện hiệu suất của chúng - tất cả đều không cần server administration. Lambda@Edge chạy code của chúng ta để phản hồi các sự kiện được tạo ra bởi Amazon CloudFront content delivery network. Chỉ cần upload code của chúng ta lên AWS Lambda, ứng dụng này sẽ xử lí mọi thứ cần thể để run và scale code của chúng ta với tính khả dụng cao tại một AWS location gần với end user nhất của chúng ta.\nCloudFront Edge Compute Triggers Amazon CloudFront yêu cầu 4 loại event khác nhau để custom request và response được trao đổi giữa viewer và server (origin).\nViewer Request - Function này thực thi khi CloudFront nhận được request từ viewer và trước khi nó kiểm tra xem đối tượng được yêu cầu có trong edge cache hay không.\nOrigin Request - Function này chỉ thực thi khi CloudFront chuyển tiếp request đến origin của chúng ta. Khi request object nằm trong edge cache, function không được thực thi.\nOrigin Response - Function này thực thi sau khi CloudFront nhận được response từ origin và trước khi nó cache object trong response.\nViewer Response - Function thực thi trước khi trả lại requested object cho viewer. Function thực thi bất kể object đã có trong edge cache hay chưa.\nTất cả 4 trigger options trên đều khả dụng với Lambda@Edge trong khi chỉ có viewer triggers khả dung với CloudFront Functions. Đây là một trong những điểm khác biệt và quan trọng nhất giữa hai feature trên và chúng ta sẽ khám phá thêm về feature Lambda@Edge trong suốt bài workshop.\nCloudFront Edge Locations và Regional Edge Caches (RECs) CloudFront Edge Locations là những điểm hiện diện nơi các request của user sẽ được gửi đến dựa trên độ trễ thấp nhất đối với user gửi yêu cầu đó. Content của CloudFront Delivers được detect bằng những thứ mà Edge Location có thể phục vụ request và định tuyến users đến Edge Locations đã được xác định.\nRegional Edge Cache là middle tier caching layer nằm giữa Edge Location và Origin. Các Regional Edge Cache servers được dùng để cho phép nhiều content hơn được cache gần hơn với user.\nBiểu đồ sau đây biểu diễn cách nhóm Edge Locations và Regional Edge Cache được CloudFront sử dụng:\n"
},
{
	"uri": "/vi/3-cache/3.2-geored/",
	"title": "Geo Location Redirects",
	"tags": [],
	"description": "",
	"content": "Trường hợp này thường được dùng để redirect viewer đến country page của website của chúng ta. Ở sơ đồ dưới đây, chúng ta có thể thấy cấu trúc được build cho phần này.\nStep 1: Tạo CloudFront Cache policy để chuyển tiếp country header: Để có thể Redirect user dựa vào country location. Chúng ta cần đảm bảo rằng Contry Headeer liên kết với Lambda@Edge function. Để làm được điều này, chúng ta cần tạo Cache Policy nơi header được thêm vào cache key.\nĐến trang CloudFront Cache Policies console.\nỞ mục Custom Policies, click vào nút Create cache policy.\nỞ trang Create cache policy, đặt tên cho nó là edge-redirect-cache-policy. Ở phần Cache key settings, mở rộng phần Headers ra và chọn Include the following headers. Ở phần Add header, chúng ta tìm kiếm CloudFront-Viewer-Contry và chọn nó. Những mục khác chúng ta để mặc định và click vào nút Create. Step 2: Tạo Lambda@Edge function và publish new version Ở bước này, chúng ta sẽ làm như ở phần trước, tạo Lambda function với tên edge-geo-redirect, Runtime là Python 3.9 và deploy nó. Sau đó, chúng ta cần publish new version của Lambda function vừa tạo.\nCode source của Lambda function này là:\nimport json\rdef lambda_handler(event, context):\r#Let\u0026#39;s first get the Country Code from the Request coming in\rget_country_viewer_header = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;headers\u0026#39;][\u0026#39;cloudfront-viewer-country\u0026#39;]\rdefine_country = get_country_viewer_header[0][\u0026#39;value\u0026#39;]\r#Now let\u0026#39;s define which country that is and create our redirected response\rif (define_country == \u0026#39;US\u0026#39;):\rresponse = {\r\u0026#39;status\u0026#39;: \u0026#39;301\u0026#39;,\r\u0026#39;statusDescription\u0026#39;: \u0026#39;Permanent Redirect\u0026#39;,\r\u0026#39;headers\u0026#39;: {\r\u0026#39;location\u0026#39;: [{\r\u0026#39;key\u0026#39;: \u0026#39;Location\u0026#39;,\r\u0026#39;value\u0026#39;: \u0026#39;/en-us.html\u0026#39;\r}]\r}\r}\r#The response above has been created and a response will be sent to the viewer to redirect it to the /en-us.html\rreturn response\relse:\r#if the country has not been identified then move on with the request\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request Step 3: Tạo CloudFront behavior cho trường hợp này Bây giờ Lambda function vừa được tạo và chúng ta phải assign nó cho một Cache Behavior trong CloudFront.\nĐi đến CloudFront console. Các bạn sẽ thấy Distribution được tạo ra bởi CloudFormation template, nó sẽ được xác định bởi Edge Redirect Workshop Distribution như ở mục Description.\nChọn Distribution đó sau đó chọn vào mục Behaviors.\nClick vào nút Create Behavior.\nỞ mục Path pattern, chúng ta nhập /geo.html. Ở dưới là phần Origin and origin groups, chúng ta chọn myS3Origin. Ở phần Viewer protocol policy, chúng ta chọn Redirect HTTP to HTTPS. Ở mục Cache key and origin requests, chúng ta chọn Cache policy and origin request policy, tiếp theo mở rộng mục Cache policy, chúng ta chọn policy vừa tạo ở bước trên edge-redirect-cache-policy. Những mục còn lại chúng ta sẽ để mặc định và click vào nút Create behavior ở cuối trang.\nStep 4: Kết hợp Lambda Function với CloudFront Behavior Chúng ta làm như ở trường hợp URI based Redirects ở trên, chúng ta sẽ kết hợp Lambda function edge-geo-redirect với CloudFront Behavior vừa tạo ở trên.\nStep 5: Set up clients cho testing Chúng ta sẽ cần một client để chạy curl commands. Cách dễ dàng đó là tạo CloudShell Environments. CloudShell là một shell có sẵn trong AWS console và chúng ta có thể chạy những Linux command từ nó. Đi đến CloudShell Console và chờ đến khi terminal sẵn sàng để dùng.\nNếu CloudShell không hoạt động thì nếu bạn đang thực hành bài workshop này ở Linux/MacOS client thì hai hệ điều hành này đã có sẵn curl và bạn chỉ cần chạy command ở client đó. Nếu bạn đang thực hành trên Windows thì hãy tận dùng online curl tools như cái này. Có thể chạy EC2 instance hoặc Cloud9 IDE từ AWS COnsole để chạy commands.\nStep 6: Test redirect configuration Đi đến CloudShell Console ở AWS Region us-east-1.\nTrong phần test, chúng ta sẽ chạy câu lệnh curl để gửi http request đối với distribution của chúng ta, để làm như vậy, chúng ta cần copy Distribution domain name từ CloudFront console nơi chúng ta có thể tìm thấy.\nKhi đã tìm thấy distribution domain name, copy câu lệnh sau và thay thế domain name của chúng ta vào.\ncurl -v -o /dev/null https://\u0026lt;YOUR-DISTRIBUTION-DOMAIN-NAME\u0026gt;/geo.html Sau khi build câu lệnh trên từ cloudshell, chúng ta sẽ thấy kết quả như dưới đây. \u0026lt; HTTP/1.1 301 Moved Permanently\r\u0026lt; Content-Length: 0\r\u0026lt; Connection: keep-alive\r\u0026lt; Server: CloudFront\r\u0026lt; Location: /en-us.html\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 6fbeae74487f866b555dc44d03fcc2a6.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: MIA3-P3\r\u0026lt; X-Amz-Cf-Id: VRNhLpCaNiZ08Fw5f2eMtWn8KfHnkPp3qp4kQeft3CVfEjo6kXIEWQ== Hãy chạy lại câu lệnh trên một lần nữa ở AWS Region us-east-1. Chúng ta sẽ thấy response khác nhau. \u0026lt; HTTP/1.1 301 Moved Permanently\r\u0026lt; Content-Length: 0\r\u0026lt; Connection: keep-alive\r\u0026lt; Server: CloudFront\r\u0026lt; Location: /en-us.html\r\u0026lt; X-Cache: Hit from cloudfront\r\u0026lt; Via: 1.1 e759cef9ef04dc6632a71818dfac3a76.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: MIA3-P3\r\u0026lt; X-Amz-Cf-Id: aOe3ADve7yDyHH_Iyb7MGMPAX8LWuTli79qf-nFl8rT40-VxPb_Zeg==\r\u0026lt; Age: 158 Chỉ có sự khác biệt ở đây là X-Cache response header. Chúng ta sẽ thấy Hit from cloudfront vì ở response đầu tiên sau khi request, nó đã được cache ở CloudFront nên request thứ hai sẽ không cần phải đi qua tất cả function thay vào đó nó sẽ chỉ được hoạt đồng từ cached content, điều này cung cấp hiệu suất tốt hơn và cũng giúp tiết kiệm chi phí vì function không cần trigger lần nữa.\nBây giờ, quay trở lại shell console và chạy cùng câu lệnh trên ở AWS Region eu-west-1. Bây giờ response của chúng ta sẽ không phải là HTTP 301 mà là HTTP 200 OK như dưới đây. \u0026lt; HTTP/1.1 200 OK\r\u0026lt; Content-Type: text/html\r\u0026lt; Content-Length: 98\r\u0026lt; Connection: keep-alive\r\u0026lt; ETag: \u0026#34;be3c901839ae019e0c58908e45f5ab45\u0026#34;\r\u0026lt; Accept-Ranges: bytes\r\u0026lt; Server: AmazonS3\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 9bbdfc2323989883f386114cc53fdbd0.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: MIA3-P3\r\u0026lt; X-Amz-Cf-Id: 2UlANwUbwF5Mv1V-XKWcYWKrTzIJZh2asxxw_xOK7aahkVP6TS6tRg==\r\u0026lt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;Not our US page\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;Not our US page\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt; Response HTTP 200 OK của request này nghĩa là nó không được redirected và thay vào đó, resouce được request đã được CloudFront cung cấp.\nVậy là chúng ta đã deploy thành công redirect logic sử dụng Lambda@Edge và đã test xong. Trường hợp này có thể mở rộng ra phức tạp hơn, xác định không chỉ ở Contry mà còn cả các vị trí địa lí khác như States, Cities, postal codes, time zone. Tham khảo tài liệu này để tìm hiểu thêm về tất cả header location có thể có trong CloudFront.\n"
},
{
	"uri": "/vi/2-prerequiste/",
	"title": "Solution Deployment",
	"tags": [],
	"description": "",
	"content": "Cách làm này sẽ thực hiện việc tạo ra các services để phục vụ cho bài workshop này. Các services này sẽ được tạo ra bằng cách sử dụng AWS CloudFormation. AWS CloudFormation là một dịch vụ của AWS giúp chúng ta tự động hóa việc triển khai các tài nguyên của AWS. Chúng ta sẽ sử dụng AWS CloudFormation để tạo ra CloudFront distribution, Amazon S3 Bucket và IAM Role.\nHãy cùng deploy template này như dưới đây:\nKhởi chạy CloudFormation template này, chúng ta sẽ nhận được một giao diện như sau: Ở trong trang này, lướt xuống phần Capabilities, chọn vào ô \u0026ldquo;I acknowledge that AWS CloudFormation might create IAM resources with custom names.\u0026rdquo; và nhấn vào nút Create stack. Sẽ mất vài phút để stack này được tạo ra thành công. Bạn sẽ thấy tương tự như hình bên dưới. Tiếp tục, hãy tải file html (sẽ phục vụ cho Origin của chúng ta). Tải ở đây. Lưu trữ nó ở máy của chúng ta và giải né. File này sẽ bao gồm file html mà chúng ta sẽ sử dụng cho Origin content. Bây giờ chúng ta hãy di chuyển sang trang S3 bucket. Chúng ta sẽ thấy S3 bucket được tạo ra bởi CloudFormation template của chúng ta. Click vào S3 bucket đó, click vào nút Upload. Click vào nút Add files, chọn file html đã tải ở trên và tải file đó lên S3 bucket của chúng ta. Vậy là chúng ta vừa hoàn thành xong việc cài đặt môi trường. Bây giờ chúng ta có thể bắt đầu thực hành với bài workshop của chúng ta.\nChúng ta có thể deploy resource của chúng ta theo cách khác đó là CDK Project. Chúng ta sẽ dùng CloudShell ở AWS Region us-east-1. Tải file CDK project dưới dạng zip ở đường dẫn này. Và đọc tài liệu hỗ trợ cho deploy CDK project ở đây.\nHãy cùng xem lại tất cả resources được deploy để hiểu hơn về bài workshop của chúng ta. Rồi hãy cùng bắt tay vào thực hành.\n"
},
{
	"uri": "/vi/3-cache/3.3-devicered/",
	"title": "Device Redirects",
	"tags": [],
	"description": "",
	"content": "Trường hợp này được sử dụng để redirect viewer đến proper page của website dựa trên loại thiết bị gửi request đó. Sơ đồ sau đây cho thấy kiến trúc và các requested steps mà chúng ta sẽ làm trong phần này.\nStep 1: Tạo CloudFront Cache policy để chuyển tiếp device type header: Để có thể Redirect user dựa vào device type, CloudFront headers xác định device type của user sẽ liên kết đến Lambda@Edge function. Để làm được cái đó, bạn sẽ cần tạo Cache Policy trong đó header được thêm vào cache key. Trong bài workshop này, bạn sẽ sử dụng CloudFront-Is-Mobile-Viewer những cũng có sẵn những headers khác.\nĐến trang CloudFront Policies console. Chúng ta làm tương tự như phần Geo Location Redirects ở trên, chúng ta tạo một Cache Policy có tên là device-redirect-cache-policy. Và ở Headers của phần Cache key settings, chúng ta tìm kiến và chọn CloudFront-Is-Mobile-Viewer. Cuối cùng, chúng ta click vào nút Create.\nStep 2: Tạo Lambda@Edge function và publish new version Ở bước này, chúng ta sẽ làm như ở phần trước, tạo Lambda function với tên edge-device-redirect, Runtime là Python 3.9 và deploy nó. Sau đó, chúng ta cần publish new version của Lambda function vừa tạo.\nCode source của Lambda function này là:\nimport json\rdef lambda_handler(event, context):\rprint(event)\r#Let\u0026#39;s first get the Device Type from the Request coming in\rget_device_viewer_header = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;headers\u0026#39;][\u0026#39;cloudfront-is-mobile-viewer\u0026#39;]\rdefine_device_type = get_device_viewer_header[0][\u0026#39;value\u0026#39;]\rprint(define_device_type)\r#Now let\u0026#39;s see if this device is a mobile viewer or not and create the redirected response based on that\rif (define_device_type == \u0026#39;true\u0026#39;):\rresponse = {\r\u0026#39;status\u0026#39;: \u0026#39;301\u0026#39;,\r\u0026#39;statusDescription\u0026#39;: \u0026#39;Permanent Redirect\u0026#39;,\r\u0026#39;headers\u0026#39;: {\r\u0026#39;location\u0026#39;: [{\r\u0026#39;key\u0026#39;: \u0026#39;Location\u0026#39;,\r\u0026#39;value\u0026#39;: \u0026#39;/mobile.html\u0026#39;\r}]\r}\r}\r#The response above has been created and a response will be sent to the viewer to redirect it the right device page\rreturn response\relse:\r#if the device is not mobile, then move along with the request as is.\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request Step 3: Tạo CloudFront behavior cho trường hợp này Bây giờ Lambda function vừa được tạo và chúng ta phải assign nó cho một Cache Behavior trong CloudFront. Chúng ta làm như phần Geo Location Redirects ở trên. Với Path Pattern, chúng ta nhập /device.html và hãy nhớ chọn Cache policy là device-redirect-cache-policy vừa được tạo ở trên.\nStep 4: Kết hợp Lambda Function với CloudFront Behavior Chúng ta làm như ở phần Geo Location Redirects ở trên, chúng ta sẽ kết hợp Lambda function edge-device-redirect với CloudFront Behavior vừa tạo ở trên.\nStep 5: Set up clients cho testing Chúng ta sẽ cần một client để chạy curl commands. Cách dễ dàng đó là tạo CloudShell Environments. CloudShell là một shell có sẵn trong AWS console và chúng ta có thể chạy những Linux command từ nó. Đi đến CloudShell Console và chờ đến khi terminal sẵn sàng để dùng.\nNếu CloudShell không hoạt động thì nếu bạn đang thực hành bài workshop này ở Linux/MacOS client thì hai hệ điều hành này đã có sẵn curl và bạn chỉ cần chạy command ở client đó. Nếu bạn đang thực hành trên Windows thì hãy tận dùng online curl tools như cái này. Có thể chạy EC2 instance hoặc Cloud9 IDE từ AWS COnsole để chạy commands.\nStep 6: Test redirect configuration Đi đến CloudShell Console.\nTrong phần test, chúng ta sẽ chạy câu lệnh curl để gửi http request đối với distribution của chúng ta, để làm như vậy, chúng ta cần copy Distribution domain name từ CloudFront console nơi chúng ta có thể tìm thấy.\nKhi đã tìm thấy distribution domain name, copy câu lệnh sau và thay thế domain name của chúng ta vào.\ncurl -v -o /dev/null https://\u0026lt;YOUR-DISTRIBUTION-DOMAIN-NAME\u0026gt;/device.html Sau khi build câu lệnh trên từ cloudshell, chúng ta sẽ thấy kết quả như dưới đây. \u0026lt; HTTP/1.1 200 OK\r\u0026lt; Content-Type: text/html\r\u0026lt; Content-Length: 106\r\u0026lt; Connection: keep-alive\r\u0026lt; ETag: \u0026#34;73940ca66258e1bd0a623690f24fe324\u0026#34;\r\u0026lt; Accept-Ranges: bytes\r\u0026lt; Server: AmazonS3\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 2f66aa06710fece8ed203ab0ea81eb56.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: IAD89-C3\r\u0026lt; X-Amz-Cf-Id: ChlZowW_za1QF6FVmDX2iTENoknUBJxoxpMNV6S28E37g0khLdnxwg==\r\u0026lt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;non-mobile URI Page\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;non-mobile URI Page\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt; Request trên cho thấy response thường xuyên. Điều này xảy ra đơn giản là do device mà chúng ta gửi request không được Lambda@Edge function nhận dạng là mobile device và nó cho phép request diễn ra bình thường.\nHãy chạy lại câu lệnh dưới đây. curl -v https://d2lagt3tnycm19.cloudfront.net/device.html -A \u0026#34;Mozilla/5.0 (iPhone; CPU iPhone OS 6_1_3 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) CriOS/28.0.1500.12 Mobile/10B329 Safari/8536.25\u0026#34; Chúng ta sẽ thấy response khác nhau.\n\u0026lt; HTTP/1.1 301 Moved Permanently\r\u0026lt; Content-Length: 0\r\u0026lt; Connection: keep-alive\r\u0026lt; Server: CloudFront\r\u0026lt; Location: /mobile.html\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 a4cae74c829bc214e4183c38164a2c0a.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: IAD89-C3\r\u0026lt; X-Amz-Cf-Id: sQ0_5pUMkOAJOBJUiTdDmEKGaq7ExMDotLmPsi-17WouwqcJBu7mNA==\r\u0026lt; Response ở đây hiện là HTTP 301, biểu thị redirect. Điều này xảy ra vì User-Agent theo request xác định là một mobile device, Lambda@Edge của chúng ta nắm bắt được điều đó và trả lời với một redirect.\nBây giờ, chạy câu lệnh như ở mục 4, chúng ta sẽ thấy sự khác biệt. \u0026lt; HTTP/1.1 301 Moved Permanently\r\u0026lt; Content-Length: 0\r\u0026lt; Connection: keep-alive\r\u0026lt; Server: CloudFront\r\u0026lt; Location: /mobile.html\r\u0026lt; X-Cache: Hit from cloudfront\r\u0026lt; Via: 1.1 38ecebcaa39c8742da2b6336935bb446.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: IAD89-C3\r\u0026lt; X-Amz-Cf-Id: 97bOlPobmuIto-LcDA5AbPprf6oXSniK4pq16RRpZSjVPVSb8HUr4Q==\r\u0026lt; Age: 133 Sự khác biệt chính ở đây lại là ở X-Cache header có giá trị là Hit from cloudfront, nghĩa là function này không cần chạy lại vì request đã được cache.\nVậy là chúng ta đã deploy thành công redirect logic sử dụng Lambda@Edge và đã test xong. Trường hợp này có thể mở rộng ra phức tạp hơn, xác định không chỉ là mobile device mà còn là cả Android và IOS clients, xác định SmartTVs và Tablet cũng có thể thực hiện được. Tham khảo tài liệu này để tìm hiểu thêm về tất cả header location có thể có trong CloudFront.\n"
},
{
	"uri": "/vi/3-cache/",
	"title": "Trường hợp cho Cacheable",
	"tags": [],
	"description": "",
	"content": "Xử lí Redirects bằng Lambda@Edge Trong phần này, chúng ta sẽ đề cập đến trường hợp có thể được cached. Lý tưởng nhất là các trường hợp này sẽ được xử lí bằng cách sử dụng Lambda@Edge.\nNhư đã nhắc đến trong phần Edge Compute Introduction, có nhiều triggers có sẵn cho Lambda@Edge, các trường hợp sẽ được giải quyết bằng cách sử dụng Origin facing event triggers.\nLambda@Edge Functions đang sử dụng Origin facing triggers sẽ được trigger sau khi request được đánh evaluate ở CloudFront Caching Layers, do đó, nếu có một response đã được cache thì một response sẽ được back lại viewer, tiết kiệm function invocations. Điều này không chỉ tăng tốc độ phản hồi mà còn giúp giảm chi phí redirects của chúng ta vì Lambda sẽ chỉ được kích hoặc nếu không có response nào được cached.\nNội dung Khai báo Table trong DynamoDB Tạo Lambda function "
},
{
	"uri": "/vi/4-terminate/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "SAM-created Resources Cách đơn giản nhất để xóa resources được tạo ra bởi SAM là sử dụng câu lệnh sam delete. Tuy nhiên, trước khi chạy câu lệnh đó, bạn cần chắn chắn rằng S3 bucket chứa hình ảnh tải lên đã được dọn dẹp sạch.\nBạn hãy sử dụng câu lệnh aws s3 ls để thấy được danh sách cái file trong bucket. Hãy làm như hình.\nBạn sẽ thấy bucket tên uploads-tasks-app-ap-southeast-1-127779471063 trong đó ap-southeast-1 là region của bạn và 127779471063 là ID của AWS account.\nHãy đi đến thư mục /sam bằng câu lệnh cd ~/environment/serverless-tasks-webapp/sam. Bucket của workshop này được kích hoạt versioning nên bạn phải dọn dẹp nó bằng AWS SDK. Tìm đến file emtpy_versioned_bucket.py trong thư mục /sam và modify nó bằng cách chỉnh sửa tên bucket trên sau khi chạy câu lệnh aws s3 ls. Lưu lại file và chạy câu lệnh sau để dọn dẹp bucket:\npython empty_versioned_bucket.py Chúng ta sẽ có kết quả như hình:\nBây giờ chúng ta có thể chạy câu lệnh:\nsam delete Vậy là chúng ta đã xóa thành công các resources được tạo ra bởi SAM.\nAmplify Hosting Di chuyển vào thư mục /webapp, chúng ta có thể xóa Amplify project bằng câu lệnh:\ncd ~/environment/serverless-tasks-webapp/webapp\ramplify delete Sau khi xóa thành công, chúng ta sẽ thấy như hình:\nCác bạn hãy nhớ vào IAM console, chọn user amplify-user được tạo ra ở bước 2.4 - Cài đặt Amplify CLI và xóa nó cùng Access Key được tạo ra vì nó không được tự động xóa khi chạy câu lệnh amplify delete.\nCloudWatch Logs Bạn phải xóa các nhóm log trong CloudWatch Logs và streams được tạo ra khi sử dụng ứng dụng. Hãy vào CloudWatch Logs console, tiếp theo vào Log groups ở thanh điều hướng bên trái, chọn các Log group của workshop này và xóa chúng.\nVậy là chúng ta đã dọn dẹp tất cả tài nguyên trong workshop này.\n"
},
{
	"uri": "/vi/3-cache/3.4-urirew/",
	"title": "URI based Rewrites",
	"tags": [],
	"description": "",
	"content": "Đây là một technique không liên quan đến việc redirect client browser đến một URL hoàn toàn mới. Tuy nhiên, browser sẽ tiếp tục nhận ra URI mà nó đã request, nhưng thay vì CloudFront truy xuất nó từ cùng một URI tại Original, n ó sẽ lấy nội dung từ một đường dẫn khác. Ví dụ: giả sử một browser đã gửi request tới resource www.example.com/uri-rewrite.html, nhưng bạn muốn lấy nội dung từ một đường dẫn cho backend khác hoặc thậm chí là một Orgin khác mà viewer không biết về cái này. Sau đó, bạn sẽ sử dụng Lambda@Edge function hoặc CloudFront function để làm URI rewrite và thực sự truy cập vào Origin để request một URI chẳng hạn như www.example.com/rewrite.html\nĐối với trường hợp này, chúng ta sẽ sử dụng Default Behavior từ CloudFront và sẽ không sử dụng bất kỳ header cụ thể nào để dựa trên logic function của chúng ta, vì vậy bạn cũng không cần tạo cache policy mới. Tuy nhiên, những thứ đó rất có thể được sử dụng để tạo các tình huống phức tạp hơn, trong đó thay vì redirect, chúng ta có thể rewrite URI ở backend. Ở các ví dụ trước của chúng ta trong workshop này, chúng ta có thể phát hiện location hoặc loại device của viewer và lấy một URI khác từ backend thay vì redirect user. Hình ảnh sau đây mô tả cấu trúc về những gì sẽ được xây dựng trong bài workshop này:\nStep 1: Tạo CloudFront Behavior: Xem lại ở ví dụ URI based Redirects, chúng ta tạo Behavior với Path Pattern là /uri-rewrite.html và ở mục Origin and origin group, chúng ta chọn myS3Origin.\nStep 2: Tạo Lambda@Edge function và publish new version Ở bước này, chúng ta sẽ làm như ở phần trước, tạo Lambda function với tên edge-uri-rewrite, Runtime là Python 3.9 và deploy nó. Sau đó, chúng ta cần publish new version của Lambda function vừa tạo.\nCode source của Lambda function này là:\nimport json\rdef lambda_handler(event, context):\r#let\u0026#39;s first extract the URI from the request\rget_uri = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;uri\u0026#39;]\r#let\u0026#39;s check what is the URI and decide if the URI sent to the Origin should be modified\rif (get_uri == \u0026#39;/uri-rewrite.html\u0026#39;):\revent[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;uri\u0026#39;] = \u0026#39;/rewrite.html\u0026#39;\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request\r#if the uri should not be modified then just continue with the request as is\relse:\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request Step 3: Kết hợp Lambda Function với CloudFront Behavior Chúng ta làm như ở phần Geo Location Redirects ở trên, chúng ta sẽ kết hợp Lambda function edge-uri-rewrite với CloudFront Behavior vừa tạo ở trên.\nStep 5: Set up clients cho testing Chúng ta sẽ cần một client để chạy curl commands. Cách dễ dàng đó là tạo CloudShell Environments. CloudShell là một shell có sẵn trong AWS console và chúng ta có thể chạy những Linux command từ nó. Đi đến CloudShell Console và chờ đến khi terminal sẵn sàng để dùng.\nNếu CloudShell không hoạt động thì nếu bạn đang thực hành bài workshop này ở Linux/MacOS client thì hai hệ điều hành này đã có sẵn curl và bạn chỉ cần chạy command ở client đó. Nếu bạn đang thực hành trên Windows thì hãy tận dùng online curl tools như cái này. Có thể chạy EC2 instance hoặc Cloud9 IDE từ AWS COnsole để chạy commands.\nStep 6: Test redirect configuration Đi đến CloudShell Console.\nTrong phần test, chúng ta sẽ chạy câu lệnh curl để gửi http request đối với distribution của chúng ta, để làm như vậy, chúng ta cần copy Distribution domain name từ CloudFront console nơi chúng ta có thể tìm thấy.\nKhi đã tìm thấy distribution domain name, copy câu lệnh sau và thay thế domain name của chúng ta vào.\ncurl -v -o /dev/null https://\u0026lt;YOUR-DISTRIBUTION-DOMAIN-NAME\u0026gt;/uri-rewrite.html Sau khi build câu lệnh trên từ cloudshell, chúng ta sẽ thấy kết quả như dưới đây. \u0026lt; HTTP/1.1 200 OK\r\u0026lt; Content-Type: text/html\r\u0026lt; Content-Length: 92\r\u0026lt; Connection: keep-alive\r\u0026lt; ETag: \u0026#34;a1764624bd34afb8e52157f114ef6db1\u0026#34;\r\u0026lt; Accept-Ranges: bytes\r\u0026lt; Server: AmazonS3\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 3cf1bfec064e2e01f071e8051a22d830.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: ATL56-C1\r\u0026lt; X-Amz-Cf-Id: HeF7XzxKoVyNxUKAAnP0t8bCzpwbN-pyex3mRMbqcH-mQOT5V3yjAw==\r\u0026lt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;Rewrite Page\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;Rewrite Page\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt; Request trên cho thấy direct response đối với request của chúng ta là HTTP 200 OK, nghĩa là đây không phải là redirect, thay vào đó nội dung đã được cung cấp, tuy nhiên trong trang này, bạn có thể thấy HTML được tạo cho biết đây là nội dung rewrite thay vì nội dung chính.\nVậy là chúng ta đã deploy thành công trường hợp URI rewrite. Trường hợp này có thể mở rộng để xử lí logic phức tạp hơn cũng như thậm chí truy xuất nội dụng từ các Origin khác nhau nếu được request. Trường hợp này cũng có thể được thực hiện bằng cách sử dụng các function của CloudFront nếu trường hợp của chúng tôi yêu tất cả request phải được evaluate và rewrite.\n"
},
{
	"uri": "/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]